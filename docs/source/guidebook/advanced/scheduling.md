# Планирование

## Что такое Scheduler

`Scheduler` — объект, который по графу работ (`WorkGraph`) и ресурсам (список `Contractor`) строит расписание (
`Schedule`).  
Обычно вы просто создаёте конкретный планировщик (`HEFTScheduler`, `GeneticScheduler`, `TopologicalScheduler` и т.д.) и
вызываете `.schedule(...)`.

| Параметр             | Назначение                                                            | Значение по умолчанию       | Меняем когда                                                         |
|----------------------|-----------------------------------------------------------------------|-----------------------------|----------------------------------------------------------------------|
| `scheduler_type`     | Метка семейства алгоритма (для внутренней логики и логов).            | Задаётся самим наследником. | Пишете свой класс планировщика.                                      |
| `resource_optimizer` | Стратегия подбора/урезания численности команды (баланс время / люди). | Координатный спуск.         | Нужна другая эвристика (усреднение, полный поиск, ничего не делать). |
| `work_estimator`     | Как считать длительность работ (объём → время).                       | `DefaultWorkEstimator()`    | Нужна доменная или стохастическая модель.                            |

### Минимальный паттерн

```python
# У вас есть: wg (WorkGraph), contractors (list[Contractor])
from sampo.scheduler.heft.base import HEFTScheduler

scheduler = HEFTScheduler()
schedule = scheduler.schedule(wg, contractors)[0]
print(schedule.execution_time)
```

Через пайплайн:

```python
from sampo.pipeline import SchedulingPipeline
from sampo.scheduler import GeneticScheduler

result = (SchedulingPipeline.create()
          .wg('input.csv', sep=';')
          .schedule(GeneticScheduler(number_of_generation=10))
          .finish()
          )[0]

print(result.schedule.execution_time)
```

### Кастомизация (подсказка)

| Цель                        | Действие                                         |
|-----------------------------|--------------------------------------------------|
| Своя формула времени        | Передать свой `work_estimator`.                  |
| Эксперименты с численностью | Передать иной `resource_optimizer`.              |
| Новая стратегия             | Создать наследник + установить `scheduler_type`. |

### Самая короткая формулировка

Scheduler = (Граф работ + Ресурсы) → Schedule.

---

## Что такое Timeline (коротко)

`Timeline` — внутренняя структура учёта занятости ресурсов по времени.  
Планировщик спрашивает её: «Когда можно стартовать эту работу с таким набором ресурсов?» — и фиксирует занятые интервалы
после назначения.

> В обычном использовании вы напрямую с `Timeline` не взаимодействуете.

### Что хранит концептуально

- Интервалы занятости по видам или конкретным группам ресурсов.
- Логику поиска минимального допустимого старта с учётом:
    - зависимостей (время доступно не раньше родителя + лаг),
    - занятости уже назначенных работ,
    - возможных доп. ограничений (например, зоны / ландшафт).

### Когда имеет смысл лезть внутрь

- Пишете свою стратегию планирования или визуализатор занятости.
- Отлаживаете конфликт ресурса (почему старт сдвинулся).

### Самая короткая формулировка

Timeline = «Календарь занятости ресурсов + функция earliest feasible start».

---

## Что такое ScheduledWork (коротко)

`ScheduledWork` — конкретное запланированное выполнение одной работы:

- ссылка на исходный `GraphNode` / `WorkUnit`,
- время старта и окончания,
- назначенные ресурсы (workers, equipment, материалы),
- дополнительные атрибуты (зона, производительность и т.п. если применимо).

> Это «живая» инстанциация вершины графа внутри результата.

### Использование

Обычно получаете список/слой через объекты `Schedule` (например, DataFrame или итерацию по структурам), а не создаёте
вручную.

### Самая короткая формулировка

ScheduledWork = WorkUnit + (start, finish, назначенные ресурсы).

---

## Что такое Schedule (коротко)

`Schedule` — агрегат всех `ScheduledWork`. Содержит:

- `execution_time` (makespan — от первого старта до последнего финиша),
- производные представления (таблицы, диаграммы),
- методы экспорта/фильтрации/слияния сервисных задач,
- (опционально) метаданные о порядке, ресурсной статистике, критическом пути.

> Конечный продукт планировщика.

### Пример получения длительности и таблицы

```python
schedule = scheduler.schedule(wg, contractors)[0]
print(schedule.execution_time)

df = schedule.merged_stages_datetime_df(start_date="2025-01-01")
print(df.head())
```

---